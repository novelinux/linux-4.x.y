有时候，数据结构不符合它接口的描述，有时候反过来说，正确的数据结构它的API设计却不合理。例如在2018年linux.conf.au举办的Kernel miniconf上，Matthew Wilcox演讲提到的，内核的基数树就是后面这种情况。他的回应是，用新的使用方式，去使用旧的基数树，他称之为XArray。

他认为内核的基数树本身很棒，但各个内核子系统却都不太使用它，反而又实现了自己数据结构，做了相同的事。Matthew想转换其它一些子系统的数据结构，让各个子系统都使用基数树。过程中遇到了，他认为不应该遇到的困难。他总结了下问题所在：基数树的API太糟糕了，实际开发中根本不适用。

首先一个问题，“树”这个术语就很有迷惑性。基数树跟传统的，教科书上那种树，并不是很像。举例来说，树上的增加entry的操作，一直都被称为“插入”。但对基数树而言，“插入”并不是字面上发生的事情，尤其是当key已经存在的时候。基数树也支持“异常entry“，光是这个名字，就让用户听着不敢用了。

Wilcox决定改良接口。基数树本身不变，它本身没什么问题。改变的是接口，现在接口暗示用户，把它当做数组来用，而不是当做树来用。因为基数树看起来就像是一个自动增长的数组：一个用unsigned long来索引的指针数组。这种视图，更好地描述了基数树的用途。

基数树还要求用户自己处理锁，而XArray则默认自己处理了锁，简化了使用。基数树的“预加载”机制允许用户获取锁之前先预先分配内存，这个机制在XArray中被取消了，它太复杂又没有太多实际价值。

XArray API被分为两部分，普通API和高级API。后者给用户更多可控性，比如用户可以显式管理锁。API可以用于不同的场景，满足不同的需求。比如Page Cache就可以用XArray。普通API完全在高级API的基础上实现，所以普通API也是高级API的使用范例。

Page Cache也被改为使用XArray了，目前没有已知bug了。Matthew的计划是在4.16的合并窗口里请求合并。