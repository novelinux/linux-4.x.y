Process
========================================

传统上，UNIX操作系统下运行的应用程序、服务器及其他程序都称为进程。每个进程都在CPU的虚拟内存中分配
地址空间。各个进程的地址空间是完全独立的，因此进程并不会意识到彼此的存在。从进程的角度来看，它会
认为自己是系统中唯一的进程。如果进程想要彼此通信（例如交换数据），那么必须使用特定的内核机制。由于
Linux是多任务系统，它支持（看上去）并发执行的若干进程。系统中同时真正在运行的进程数目最多不超过CPU
数目，因此内核会按照短的时间间隔在不同的进程之间切换（用户是注意不到的）

常用名词
----------------------------------------

### 进程

Linux对进程采用了一种层次系统，每个进程都依赖于一个父进程。内核启动init程序作为第一个进程，
该进程负责进一步的系统初始化操作，并显示登录提示符或图形登录界面（现在使用比较广泛）。因此
init是进程树的根，所有进程都直接或间接起源自该进程.

UNIX操作系统中有两种创建新进程的机制，分别是fork和exec。

* fork

可以创建当前进程的一个副本，父进程和子进程只有PID（进程ID）不同。在该系统调用执行之后，
系统中有两个进程，都执行同样的操作。父进程内存的内容将被复制，至少从程序的角度来看是这样。Linux
使用了一种众所周知的技术来使fork操作更高效，该技术称为写时复制（copy on write），主要的原理是将
内存复制操作延迟到父进程或子进程向某内存页面写入数据之前，在只读访问的情况下父进程和子进程可以共用
同一内存页。例如，使用fork的一种可能的情况是，用户打开另一个浏览器窗口。如果选中了对应的选项，
浏览器将执行fork，复制其代码，接下来子进程中将启动适当的操作建立新窗口。

* exec

将一个新程序加载到当前进程的内存中并执行。旧程序的内存页将刷出，其内容将替换为新的数据。然后开始执行新程序。

### 线程

进程并不是内核支持的唯一一种程序执行形式。除了重量级进程（有时也称为UNIX进程）之外，还有一种形式
是线程（有时也称为轻量级进程）。线程也已经出现相当长的一段时间，本质上一个进程可能由若干线程组成，
这些线程共享同样的数据和资源，但可能执行程序中不同的代码路径。线程概念已经完全集成到许多现代编程
语言中，例如Java。简而言之，进程可以看作一个正在执行的程序，而线程则是与主程序并行运行的程序
函数或例程。该特性是有用的，例如在浏览器需要并行加载若干图像时。通常浏览器只好执行几次fork和exec
调用，以此创建若干并行的进程实例。这些进程负责加载图像，并使用某种通信机制将接收的数据提供给主程序。
在使用线程时，这种情况更容易处理一些。浏览器定义了一个例程来加载图像，可以将例程作为线程启动，
使用参数不同的多个线程即可。由于线程和主程序共享同样的地址空间，主程序自动就可以访问接收到的数据。
因此除了为防止线程访问同一内存区而采取的互斥机制外，就不需要什么通信了。

Linux用clone方法创建线程。其工作方式类似于fork，但启用了精确的检查，以确认哪些资源与父进程共享、
哪些资源为线程独立创建。这种细粒度的资源分配扩展了一般的线程概念，在一定程度上允许线程与进程之间
的连续转换。

### 命名空间

https://github.com/novelinux/linux-4.x.y/tree/master/include/linux/nsproxy.h/README.md

### 地址空间

https://github.com/novelinux/linux-4.x.y/blob/master/mm/mmap.c/README.md

### 特权级别

内核把虚拟地址空间划分为两个部分，因此能够保护各个系统进程，使之彼此隔离。所有的现代CPU
都提供了几种特权级别，进程可以驻留在某一特权级别。每个特权级别都有各种限制，例如对执行
某些汇编语言指令或访问虚拟地址空间某一特定部分的限制。IA-32体系结构使用4种特权级别构成的系统，
各级别可以看作是环。内环能够访问更多的功能，外环则较少，如图所示:

https://github.com/novelinux/linux-4.x.y/tree/master/kernel/res/privilege.png

尽管英特尔处理器区分4种特权级别，但Linux只使用两种不同的状态：核心态和用户状态。
两种状态的关键差别在于对高于TASK_SIZE的内存区域的访问。简而言之，在用户状态禁止访问内核空间。
用户进程不能操作或读取内核空间中的数据，也无法执行内核空间中的代码。这是内核的专用领域。
这种机制可防止进程无意间修改彼此的数据而造成相互干扰。从用户状态到核心态的切换通过系统调用
的特定转换手段完成，且系统调用的执行因具体系统而不同。如果普通进程想要执行任何影响整个系统
的操作（例如操作输入/输出装置），则只能借助于系统调用向内核发出请求。内核首先检查进程是否
允许执行想要的操作，然后代表进程执行所需的操作，接下来返回到用户状态。除了代表用户程序执行
代码之外，内核还可以由异步硬件中断激活，然后在中断上下文中运行。与在进程上下文中运行的主要
区别是，在中断上下文中运行不能访问虚拟地址空间中的用户空间部分。因为中断可能随机发生，中断
发生时可能是任一用户进程处于活动状态，由于该进程基本上与中断的原因无关，因此内核无权访问当前
用户空间的内容。在中断上下文中运行时，内核必须比正常情况更加谨慎，例如，不能进入睡眠状态。
在编写中断处理程序时需要特别注意这些.

除了普通进程，系统中还有内核线程在运行。内核线程也不与任何特定的用户空间进程相关联，因此也
无权处理用户空间。不过在其他许多方面，内核线程更像是普通的用户层应用程序。与在中断上下文运转
的内核相比，内核线程可以进入睡眠状态，也可以像系统中的普通进程一样被调度器跟踪。内核线程可用
于各种用途：从内存和块设备之间的数据同步，到帮助调度器在CPU上分配进程。在多处理器系统上，
许多线程启动时指定了CPU，并限制只能在某个特定的CPU上运行。从内核线程名称之后的斜线和CPU编号可以
看到这一点。

进程生命周期
----------------------------------------

进程并不总是可以立即运行。有时候它必须等待来自外部信号源、不受其控制的事件，例如在文本编辑器
中等待键盘输入。在事件发生之前，进程无法运行。当调度器在进程之间切换时，必须知道系统中每个进程
的状态。将CPU时间分配到无事可做的进程，显然是没有意义的。进程在各个状态之间的转换也同样重要。
例如，如果一个进程在等待来自外设的数据，那么调度器的职责是一旦数据已经到达，则需要将进程的状态
由等待改为可运行。进程可能有以下几种状态。

* 运行: 该进程此刻正在执行。

* 等待: 进程能够运行，但没有得到许可，因为CPU分配给另一个进程。调度器可以在下一次任务切换时选择该进程。

* 睡眠: 进程正在睡眠无法运行，因为它在等待一个外部事件。调度器无法在下一次任务切换时选择该进程。

系统将所有进程保存在一个进程表中，无论其状态是运行、睡眠或等待。但睡眠进程会特别标记出来，
调度器会知道它们无法立即运行。睡眠进程会分类到若干队列中，因此它们可在适当的时间唤醒，
例如在进程等待的外部事件已经发生时。下图描述了进程的几种状态及其转换。

https://github.com/novelinux/linux-4.x.y/tree/master/kernel/res/task_state.png

对于一个排队中的可运行进程，我们来考察其各种可能的状态转换。该进程已经就绪，但没有运行，
因为CPU分配给了其他进程（因此该进程的状态是“等待”）。在调度器授予CPU时间之前，进程会一直
保持该状态。在分配CPU时间之后，其状态改变为“运行”（路径④）。在调度器决定从该进程收回CPU资源时，
进程状态从“运行”改变为“等待”（路径②），循环重新开始。实际上根据是否可以被信号中断，有两种
“睡眠”状态。现在这种差别还不重要，但在更仔细地考察具体实现时，其差别就相对重要了。如果进程必须
等待事件，则其状态从“运行”改变为“睡眠”（路径①）。但进程状态无法从“睡眠”直接改变为“运行”。
在所等待的事件发生后，进程先变回到“等待”状态（路径③），然后重新回到正常循环。
在程序执行终止（例如，用户关闭应用程序）后，过程状态由“运行”变为“终止”（路径⑤）。

上文没有列出的一个特殊的进程状态是所谓的“僵尸”状态。顾名思义，这样的进程已经死亡，但仍然以某种
方式活着。实际上，说这些进程死了，是因为其资源（内存、与外设的连接，等等）已经释放，因此它们
无法也决不会再次运行。说它们仍然活着，是因为进程表中仍然有对应的表项。

其原因在于UNIX操作系统下进程创建和销毁的方式。在两种事件发生时，程序将终止运行。

第一，程序必须由另一个进程或一个用户杀死（通常是通过发送SIGTERM或SIGKILL信号来完成，
这等价于正常地终止进程）;进程的父进程在子进程终止时必须调用或已经调用wait4（读做wait for）
系统调用。这相当于向内核证实父进程已经确认子进程的终结。该系统调用使得内核可以释放为子进程
保留的资源。只有在第一个条件发生（程序终止）而第二个条件不成立的情况下（wait4），
才会出现“僵尸”状态。在进程终止之后，其数据尚未从进程表删除之前，进程总是暂时处于“僵尸”状态。
有时候（例如，如果父进程编程极其糟糕，没有发出wait调用），僵尸进程可能稳定地寄身于进程表中，
直至下一次系统重启。从进程工具（如ps或top）的输出，可以看到僵尸进程。因为残余的数据在内核中
占据的空间极少，所有这几乎不是一个问题。

Data Structure
----------------------------------------

### struct task_struct

Linux内核涉及进程和程序的所有算法都围绕一个名为task_struct的数据结构建立，该结构定义如下所示:

https://github.com/novelinux/linux-4.x.y/tree/master/include/linux/sched.h/struct_task_struct.md

### struct thread_info

#### ARM

https://github.com/novelinux/linux-4.x.y/blob/master/arch/arm/include/asm/thread_info.h/struct_thread_info.md

### union thread_union

https://github.com/novelinux/linux-4.x.y/tree/master/include/linux/sched.h/union_thread_union.md

task_struct, thread_info和kernel stack之间关系:

https://github.com/novelinux/linux-4.x.y/tree/master/include/linux/sched.h/res/task_struct-thread_info-stack.jpg

init_task
----------------------------------------

init_task在Linux系统中，只有这个进程是静态分配的:

https://github.com/novelinux/linux-4.x.y/tree/master/init/init_task.c/README.md

Create
----------------------------------------

### fork

https://github.com/novelinux/system_calls/blob/master/fork.md

### kernel_thread

https://github.com/novelinux/linux-4.x.y/tree/master/kernel/fork.c/kernel_thread.md

* kthreadd

https://github.com/novelinux/linux-4.x.y/tree/master/init/main.c/rest_init.md

Schedule
----------------------------------------

https://github.com/novelinux/linux-4.x.y/tree/master/kernel/sched/core.c/__schedule.md

Execute
----------------------------------------

https://github.com/novelinux/linux-4.x.y/tree/master/fs/exec.c/README.md
