进程虚拟地址空间
========================================

简介
----------------------------------------

用户进程的虚拟地址空间是Linux的一个重要抽象: 它向每个运行进程提供了同样的系统视图,
这使得多个进程可以同时运行，而不会干扰到其它进程内存中的内存.

如下方法通常是内核用于管理用户虚拟地址空间的方法:

* 每个应用程序都有自身的地址空间，与所有其它应用程序分离.
* 通常在巨大的线性地址空间中，只有很少的段可用于各个用户空间进程，这些段彼此之间有一定距离。
  内核需要一些数据结构来有效管理这些随机分布的段.
* 地址空间只有极小的一部分与物理内存页直接关联。不经常使用的部分，仅当必要时与页帧关联.
* 内核信任自身，但无法信任用户进程。因此各个操作都伴随有各种检查，以确保程序的权限不会超出
  应有的限制，进而危机系统的稳定性和安全性.

进程要想使用虚拟内存，必须要有硬件内存管理单元MMU的支持，MMU的介绍如下所示:

https://github.com/leeminghao/doc-linux/blob/master/0.11/memory/MMU.md

布局
----------------------------------------

虚拟地址空间中包含了若干区域，其分布方式是特定于体系结构的，但所有方法都有下列共同的成分.

* 当前运行代码的二进制代码.
* 程序使用的动态库的代码.
* 存储全局变量和动态产生的数据的堆.
* 用于保存局部变量和实现函数/过程调用的栈.
* 环境变量和命令行参数的段.
* 将文件内容映射到虚拟地址空间中的虚拟内存映射.

### 经典的进程空间布局

https://github.com/novelinux/linux-4.x.y/tree/master/mm/res/old_vpm_layout.png

如果计算机提供了巨大的虚拟地址空间，那么使用上述的地址空间布局会工作得非常好。
但在32位计算机上可能会出问题. 对于每个用户进程其虚拟地址空间从0到0xc0000000,有
3GB可用. TASK_UNMAPPED_BASE起始于0x40000000, 即1GB处.糟糕的是，堆只有1GB空间可用
继续增长会进入到mmap区域. 问题在于内存映射区域位于虚拟地址空间中间. 从2.6.7引入了
一个新的虚拟地址空间布局.

### 新的进程空间布局

https://github.com/novelinux/linux-4.x.y/tree/master/mm/res/new_vpm_layout.png

其目的在于使用固定值限制栈的最大长度. 由于栈是有界的，因此安置内存映射的区域可以在栈
末端的下方开始.与经典方法相反，改区域现在是自顶向下扩展。由于堆仍然位于虚拟地址空间
中较低的区域并向上增长，因此mmap区域和堆区域可以相对扩展，直至耗尽虚拟地址空间中剩余
的区域。为确保栈和mmap区域不发生冲突，在两者之间设置一个安全间隙.

### 进程内存布局综述

https://github.com/novelinux/linux-4.x.y/tree/master/mm/vm_layout_details.md

数据结构
----------------------------------------

系统中的每个进程都有一个struct mm_struct的实例，可以通过task_struct访问.
这个实例保存了进程内存管理信息:

https://github.com/novelinux/linux-4.x.y/tree/master/include/linux/mm_types_h/mm_struct.md
